# PosedComponent

[@steveruizok](https://twitter.com/steveruizok)

Make stunning animations in Framer X.

This component implements the amazing [Pose](https://popmotion.io/pose/)
library, however the component and its author is not affiliated with PopMotion.

### âœ¨ New in 1.5.0

- Scrollables! See examples below.

# Usage

The PosedComponent works by using overrides. These overrides define several
poses. Each pose is a set of CSS properties and other options that determine what
the PosedComponent should look like in a given pose, and how
the PosedComponent should get there.

If you're familiar with Framer Classic (or Framer W), poses are very similar to
Framer States.

To get started, open your `Examples.tsx` or `App.tsx` files (wherever your
overrides are living), and
import the `createPosed` method from
`fx-posed`. You may also want to import one or more shortcut methods:

```javascript
import { Override } from "framer";
import createPosed, {
	scrollable,
	hoverable,
	pressable,
	focusable,
	draggable,
} from "fx-posed";
```

Now create your first posed override:

```javascript
const [overrides] = hoverable({
	init: {
		scale: 1,
		transition: {
			duration: 200,
		},
	},
	hover: {
		scale: 1.25,
		transition: {
			duration: 350,
		},
	},
});

export const MyHoverable: Override = () => overrides;
```

Back in Framer X, create a PosedComponent instance. It needs a child, so connect
it to another frame. Now assign this override to the PosedComponent and open up
your preview.

Congratulations! If everything's working, your component should respond to
hovers by scaling up. If things aren't working, make sure your override is set
on the PoseComponent instance (and not its child Frame).

## Creating poses with createPose

The `createPosed` method takes a single argument, an options object with three properties: an object of `poses`, an
optional `initialPose`, and an optional `pose` to enter immediately. By default,
the PosedComponent will use any pose named `init` as its `initialPose`.

The `createPosed` function returns an array containing:

- a set of overrides for the PosedComponent
- a data object that stores the current pose
- a method for manually changing the component's pose

You can destructure into whatever variables you'd like, using:

`[myOverrides, myData, mySettingMethod] = createPosed({...}`

You can also leave out the third item and mutate the value of data.pose directly.

#### Example:

A simple override might look like this:

```javascript
import { Override } from "framer";
import createPosed from "fx-posed";

const [shyOverrides, shyData, setShyPose] = createPosed({
	poses: {
		visible: { opacity: 1 },
		hidden: { opacity: 0 },
	},
	initialPose: "visible",
});

export const ShyThing: Override = () => {
	return {
		...shyOverrides,
		pose: shyData.pose,
		onTapStart() {
			setShyPose("hidden");
		},
		onTapEnd() {
			setShyPose("visible");
		},
	};
};
```

Using `createPose`, you should be able to implement the full Pose API. You can read more
about Pose [here](https://popmotion.io/pose/) - and if you find something that
doesn't work, [let me know](http://twitter.com/steveruizok)!

#### Shortcut Methods

The provided shortcut methods make it even easier to use common interactions,
automatically changing poses in response to certain user interactions and events.

Each shortcut takes as its argument an object containing poses. Its interaction
is determined by the shortcuut used: for example, to create hover animations,
use the `hoverable` shortcut. You should include two poses: `init` will be the
starting pose, and `hover` (or `drag`, `focus`, `press` for the other shortcuts)
with the properties you'd like applied when the interaction occurs.

```javascript
const [overrides] = hoverable({
	init: { scale: 1 },
	hover: { scale: 1.25 },
});

export const MyHoverable: Override = () => overrides;
```

For more thorough examples, see the shortcut examples below.

## Shortcut Examples

At the top of your overrides `App.tsx` file, the following imports. (You only
need to keep the ones you use, and can remove the others).

```javascript
import { Override } from "framer";
import createPosed, {
	hoverable,
	pressable,
	focusable,
	draggable,
	scrollable,
} from "fx-posed";
```

## Hover

### Default Hover

```javascript
const [wh0] = hoverable();

export const HoverTest0: Override = () => wh0;
```

### Hover with options

```javascript
const [wh1] = hoverable({
	init: { top: 0, scale: 1 },
	hover: { top: -12, scale: 1.1 },
});

export const HoverTest1: Override = () => wh1;
```

## Press

### Default Press

```javascript
const [wp0] = pressable();

export const PressTest0: Override = () => wp0;
```

### Press with options

```javascript
const [wp1] = pressable({
	init: { scale: 1 },
	press: { scale: 1.25 },
});

export const PressTest1: Override = () => wp1;
```

### Press with events

```javascript
const data = Data({ mode: "night" });

const [wp2] = pressable();

export const PressTest2: Override = () => ({
	...wp2,
	onPressStart() {
		data.mode = "day";
	},
	onPressEnd() {
		data.mode = "night";
	},
});
```

## Scroll

The `scrollable` shortcut works slightly differently. It accepts an object with
a `from` and `to` pose, as well as a `distance` to determine how far the scroll
should move before reaching the `to` pose. By default, the distance starts from
zero, however you can give the shortcut a `start` property to start at a later
point in the scroll. By default, the scroll works on the vertical axis, but you
cna change this with the `direction` property.

Unlike the other shortcuts, `scrollable` also outputs two overrides: one for the Posed
Component and another for the Scroll component you'd like to drive the animation.

### Default Scrollable

```javascript
const [posedComponentOverrides, scrollComponentOverrides] = scrollable();

export const posedComponentOverride: Override = () => posedComponentOverrides;

export const scrollComponentOverride: Override = () => scrollComponentOverrides;
```

### Horizontal Scrollable

```javascript
const [posedComponentOverrides, scrollComponentOverrides] = scrollable({
	direction: "horizontal",
});

export const posedComponentOverride: Override = () => posedComponentOverrides;

export const scrollComponentOverride: Override = () => scrollComponentOverrides;
```

### Scrollable with To/From

You can describe properties for the from and to states just as you would any
other pose, except without a transition.

```javascript
const [posedComponentOverrides, scrollComponentOverrides] = scrollable({
	from: {
		opacity: 0,
		left: -100,
	},
	to: {
		opacity: 1,
		left: 0,
	},
	start: 32,
	distance: 128,
	direction: "vertical",
});

export const posedComponentOverride: Override = () => posedComponentOverrides;

export const scrollComponentOverride: Override = () => scrollComponentOverrides;
```

### Hiding Scrollables

Since Frames block touch events, even when at `opacity: 0`, you may want to hide
a scrollable before its start or after it's reached its end (start + distance).
For this, you can use the `hideBefore` and `hideAfter` properties. Note that at the
moment there's no support here for multiple keyframes, e.g. fade in and also
fade out, so you'll probably not want to use both.

```javascript
const [pcOverrides, scOverrides, posedData] = scrollable({
	from: { opacity: 0 },
	to: { opacity: 1 },
	hideAfter: true,
});

export const posedComponentOverride: Override = () => ({
	...pcOverrides,
	visible: posedData.visible,
});

export const scrollComponentOverride: Override = () => scOverrides;
```

### Multiple Scrollables

If you'd like multiple objects to respond to the same scrollable, connect them
as so:

```javascript
const [pcA, scA, scrollAData, scrollCallbackA] = scrollable();
const [pcB, scB, scrollBData, scrollCallbackB] = scrollable();

export const posedComponentAOverride: Override = () => pc0;
export const posedComponentBOverride: Override = () => pc0;

export const scrollComponentOverride: Override = () => ({
  onMove(point) {
    scrollCallbackA(point);
    scrollCallbackB(point);
  });
```

## Focus

### Default Focus

```javascript
const [wf0] = focusable();

export const focusTest0: Override = () => wf0;
```

## Drag

### Default drag

```javascript
const [wd0] = draggable();

export const dragTest0: Override = () => wd0;

const [wd1] = draggable({
	init: { scale: 1, opacity: 1 },
	drag: { scale: 1.2, opacity: 0.6 },
});

export const dragTest1: Override = () => wd1;
```

### Drag with DragEnd

```javascript
const [wd2] = draggable({
	dragEnd: {
		x: 0,
		y: 0,
		transition: { type: "spring" },
	},
});

export const dragTest2: Override = () => wd2;
```

### Drag with dragBounds

```javascript
const [wd3] = draggable({
	dragBounds: {
		left: -100,
		right: 100,
		top: -100,
		bottom: 100,
	},
	dragEnd: { x: 0, y: 0, transition: { type: "spring" } },
});

export const dragTest3: Override = () => wd3;
```

## Transitions

### Linear

```javascript
const [wt0] = pressable({
	init: {
		left: 0,
		transition: {
			duration: 618,
		},
	},
	press: {
		left: 800,
		transition: {
			duration: 1000,
		},
	},
});

export const transitionTest0: Override = () => wt0;
```

### Spring

```javascript
const [overrides] = pressable({
	init: {
		left: 0,
		transition: { type: "spring", stiffness: 100 },
	},
	press: {
		left: 800,
		transition: { type: "spring", stiffness: 60 },
	},
});

export const transitionTest1: Override = () => overrides;
```

## Passive Props

### Position / Opacity Modulation

```javascript
const [wpp1] = draggable({
	draggable: "x",
	passive: {
		opacity: ["x", v => 1 - Math.abs(v / 150)],
	},
});

export const passiveTest1: Override = () => wpp1;
```

# Changelog

### 1.5.0

- Scrollables!
